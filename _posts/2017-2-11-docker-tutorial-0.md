---
layout: post
title: Docker教程（前言）
---

在Docker的官网，Docker的设计师们对Docker的定义是：

> Docker is an open platform for developers and sysadmins to build, ship, and run distributed applications. Consisting of Docker Engine, a portable, lightweight runtime and packaging tool, and Docker Hub, a cloud service for sharing applications and automating workflows, Docker enables apps to be quickly assembled from components and eliminates the friction between development, QA, and production environments. As a result, IT can ship faster and run the same app, unchanged, on laptops, data center VMs, and any cloud.
>
> Docker是为开发者和系统管理员提供的一套用于创建、发布和运行分布式应用的开放平台。它由Docker引擎（一个可移植的轻量级运行环境和打包工具）和Docker Hub（用于分享应用和提供自动化工作流的云服务）组成。Docker可以通过组件快速地组合成应用，并且减少开放、QA和发布环境之间的摩擦。最终，IT工程师能快速地将应用毫无更改地发布到笔记本、数据中心的虚拟机和所有的云环境上。

要理解Docker官网的这段话，我们需要了解网络应用的演变历程。

以Email为代表的早期网络应用，通常是由开发商按照标准开发，并运行在特定操作系统和硬件之上的服务。这种服务往往业务单一且固定，容量有限且不容易扩充。而另一方面，这些网络应用往往必须运行在特定操作系统、运行环境甚至硬件之上，这大大增加了网络应用的开发和运营成本。

随着网络基础设施的飞速发展，更多样的网络应用得以实现。服务提供商必须在竞争对手之前提供更加灵活可用、更加廉价、更大容量的新服务。这使得开发工程师与网络工程师在开发、升级、维护和扩展网络应用服务时遇到了前所未有的挑战。在上世纪90年代、Sun在兼并多家公司和项目之后，创造出运行在虚拟机之上的Java语言，这几乎实现了“让程序员写出能在任何计算机上运行”的梦想。就在今年（2014年）兼并了Sun公司的Oracle公司发布了最新的Java8。但是Java在性能、功能和开发速度等方面的局限使得Java在大部分领域无法满足业务需要，同时Java开发和发布时同样会遇到了版本兼容、运行环境复杂和升级困难的情况。为了能隔离出每个程序和系统合适的运行环境，同时最大限度的利用硬件资源，虚拟化技术得到了广泛应用。通过使用虚拟化技术，平台服务提供商大大简化了硬件设备的部署与维护工作。使得他们可以用更少的硬件和更少的维护人员为更多的客户提供统一高效的平台服务，Paas(Platform as a service)从此大行其道。在Paas的基础上，服务提供商也通过推行Saas(Software as a service)的概念，为用户提供更灵活和廉价的服务。

虚拟化技术自身经历了全虚拟化、半虚拟化和硬件辅助虚拟化的发展过程。随着Inter和AMD两家芯片巨头在硬件级别上对虚拟化给予越来越好的支持，虚拟化技术带来的性能损失正在逐渐减少。根据网上一些测评显示，虚拟化技术在整体性能上损失在40%左右<sup>1</sup>。在CPU性能、内存消耗和磁盘IO速度几个方面，虚拟化技术的损失各有不同。随着CPU对虚拟化支持程度的加大，CPU性能的损失变得越来越小。随着内存硬件技术的提升，内存消耗很少会成为系统瓶颈。而虚拟化技术在磁盘IO速度反面一直饱受争议。在网上，我找到了一篇专门对各种虚拟化产品和NSF进行磁盘IO性能测试的文章<sup>2</sup>。文章显示，虚拟化产品在访问共享文件时，性能出现巨大损失。这使得虚拟化技术在处理共享文件时存在巨大问题。

为了更好的利用宿主主机性能，更小的虚拟化损失，操作系统级虚拟化技术越来越受到关注。操作系统级虚拟化技术提供了一种轻量化的虚拟化实现方式。它与传统硬件虚拟化产品提供完全独立的操作系统内核不同，操作系统级虚拟化使用宿主主机的操作内核，从而减少了在指令模拟、指令翻译和资源共享上的损失。

Docker正是在借鉴和总结chroot、OpenVZ和LXC等操作系统级虚拟化项目基础上，开发的一套系统全面的虚拟化应用技术平台。之所以称之为平台，是因为，Docker不只是一个程序或者软件。它始终将自己定位成提高资源使用率、降低开发和维护成本的平台。Docker不但提供了程序，还设计了一套完整的开发、部署和维护流程，并为之建立相应的平台支持。

Docker平台主要由两部分组成：

* Docker引擎

    Docker为应用提供了一个虚拟化运行容器，Docker的运行容器轻巧而功能强大，用户可以按照Docker提供的工具与工作流创建并容器化自己的应用。
	
* Docker Hub平台

    一个有Docker提供的共享与管理各种应用的平台。平台上有官方提供的各种常用的应用运行环境，也有用户按照自身需求定制的运行环境。
	
Docker的设计者们希望通过Docker引擎与Docker Hub平台的协作，能够为开发工程师和系统工程师提供一个使用方便、管理简单、能快速发布和扩展、并充分利用硬件资源的虚拟化平台。这也是长期以来，各个虚拟化系统开发商竭尽所能努力的方向。在技术方面、Docker其实并没有另辟蹊径，更多的是对现有的技术进行了整合、优化和提升。但这足以让Docker在众多虚拟化系统开发商中脱颖而出，成为2014年虚拟化技术领域的超级新星。

在Docker大红大紫的同时，也有不少经验丰富的系统工程师，在接触Docker之后提出了对Docker的一些不同的看法<sup>3</sup>：

* Docker不能完成所有工作

    对于很多初学网络应用开发与管理的工程师来说，Docker是否能成了他们跳过学习服务器管理、理解服务器架构，直接创建和维护网络应用的灵丹妙药？
	
    很显然、答案是否定的。实际上Docker的设计目标并不涉及也无法涵盖各种网络应用所需要的系统架构设计。如果你不想学习如果优化MySQL来为自己的应用提供合适的服务、不想学习如何设计和配置MemoryCached来实现Cache一致性。那么，选择阿里云的ACE、Google的App Engine或者微软的Azure等Paas服务是更好的选择。
	
* Docker是否真的能让系统配置变得简单？

	目前来说，Docker提供的系统配置方案是先进的，但对于已经使用Ansible等工具的网络来说，替换成Docker配置方案本身并不能带来多少优势。毕竟Ansible是一个足够优秀的产品，所有，往往，系统工程师会将Docker至于Ansible管理之下。也就是说，Docker本身并没有给系统配置带来方便，反而增加了难度。
	
	的确，对于正在使用和准备使用Ansible等不错的系统配置管理工具的系统工程师来说，使用Docker是一个痛苦的抉择。特别是在Docker自身的系统配置管理功能还在开发与优化的现阶段，这种替换会让决策层感觉到无畏的风险与挑战。
	
* 真实系统远比Docker示例要复杂得多

	无论是网上各种教程与介绍，还是Docker官方提供的示例，都只是示例而已。真正运营的系统所涉及到的各种问题要远远比示例复杂，Docker是否能满足真实运营环境的需求还有待更多案例来证明。而本书也正是与其他简单教程不同，不但详细系统的介绍Docker平台的使用方法，更着眼于为读者介绍Docker在真实运营环境下的各种典型案例，为读者在真正实施Docker虚拟化提供帮助。 

至此，我们已经了解的Docker的大致轮廓。而Docker所提供的服务器核心是降低成本，无论是提供产品开发、测试、维护和管理的平台一致性，还是提供各种组件来快速搭建系统，亦或是提供更轻量级的运行容器，都是以降低成本，提高效率为最终目的。如果Docker不能为你的系统降低成本，那么，你不需要（或者暂时不需要）将Docker融入你的系统。

接下的章节，我们开始正式接触Docker。在此之前，你可以喝杯咖啡，调整好心情，大战即将开始！